---
title: "**Market basket analysis - documentation**"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

#### Load libraries & Setup ####
#install.packages("pacman")
library(pacman)
p_load(caret, lattice, readr, Metrics, corrplot, e1071, mlr, recipes, ggplot2, 
       C50, party, reshape, dplyr,markdown, ggpubr, tidyr, hydroGOF, BBmisc, 
       tidyverse, textclean, inum, doParallel, Hmisc, caretEnsemble, mboost, 
       clsuter, ade4, factoextra, asbio, FactoMineR, fpc,e1071, 
       randomForest, rstudioapi, MASS, ParamHelpers, mlr,
       arules,      # analyzing transactional data
       arulesViz,    # provides visual techniques for the arules package.
       RColorBrewer,
       plyr,
       here,         #relative path
       shiny         #dashboard for R
       )

# Enable parallel computing
cl <- makePSOCKcluster(4)
registerDoParallel(cl)

# Disable scientific notation
options(scipen = 999)

# File directory
RPROJ <- list(PROJHOME = normalizePath(getwd()))
attach(RPROJ)
rm(RPROJ)
```

# Executive summary  

**Case**  
  
  
**Procedure**  
xyz  
  
**Results**  
xyz  
  
**Limitations**  
  
**Recommendations**  
  
  
# Technical documentation  
  
**Table of contents**  
1. [Exploration and preparation of data ](#Exploration and preparation of data )  
    1.1 [Placeholder](#Placeholder)  
2. [Comparison of product portfolio](#Comparison)  
3. [Analysis on customer segments (B2C, B2B)](#Customer segments)  
4. [Association rules mining](#Association rules)  
5. [Selection of rules](#Selection of rules)  

```{r Loading data, message = FALSE, warning = FALSE, include = FALSE}
#### Loading data ####

## Electronidex ##
#Load transaction into class transaction (sparse matrix)

transactions_raw <- read.transactions(file = here("Data", "ElectronidexTransactions2017.csv"), 
                                      header = FALSE, format = "basket", sep = ",", rm.duplicates = TRUE)# rm.duplicates = FALSE)
#Load transaction into class df
df_raw <- read.csv(file = here("Data", "ElectronidexTransactions2017.csv"), header = FALSE)

#Load itemlevels (new name, brand, category) into class df
df_names <- read.csv(file = here("Data", "List_il_new.csv"), header = TRUE)

brand <- read.csv(file = here("Data", "il_brand.csv"), header = TRUE)
brand_vector <- as.character(brand$brand)

#Safe itemNames
write.table(itemLabels(transactions_raw), file = here("Data", "itemLabels_raw.csv"), sep = ",")

## Blackwell Electronics ##
be_ex <- read.csv(file = here("Data", "blackwell_existing.csv"), header = TRUE)
be_new <- read.csv(file = here("Data", "blackwell_new.csv"), header = TRUE)
```
  
<a name="Exploration and preparation of data"></a>  
  
  
## 1. Exploration and preparation of data  
  
```{r Data exploration, echo = FALSE, message = FALSE, warning = FALSE}
## 1. Exploring - Get to know the data ## 
transactions_raw
summary(transactions_raw) 
sum(size(transactions_raw))/length (transactions_raw)  #Avg. transaction size

##Visualization 
# Create an item frequency plot
itemFrequencyPlot(transactions_raw, topN = 20, type = "absolute", horiz = TRUE, 
                  col = brewer.pal(8,'Pastel2'), main = "Absolute frequency of Top 20 items", 
                  xlab = "Item frequency")

# Plot image of distribution of random items
image(sample(transactions_raw, size = 300)) # of Transactions you'd like to plot))
```

```{r Data preparation, include = FALSE}
#Change data type of df to character 
for(i in c(1:32)){
  df_raw[,i] <- as.character(df_raw[,i])
}
str(df_raw)

#Change data type of df itemLevels
for(i in c(1:ncol(df_names))){
  df_names[, i] <- as.character(df_names[, i])
}

#Transfer transaction matrix via logical into binary
df_trans_log <- as.data.frame(as(transactions_raw, "matrix"))
df_trans_bin <- df_trans_log

for (i in c(1:ncol(df_trans_bin))){
  df_trans_bin[, i] <- as.integer(df_trans_bin[, i]) 
} 
```
  
```{r itemLabel (df), eval = FALSE, include = FALSE}
#Getting il_raw
il_raw <- itemLabels(transactions_raw)  

#Getting brand level (brand search)
df_names[, "brand_found"] <- NA
for (i in c(brand_vector)) {
  for (j in c(1:125)) {
    items_found <- agrep(as.character(i), df_names[, which(colnames(df_names) == "il_raw")],  max.distance = 0, 
                         ignore.case = TRUE, value = FALSE)
    df_names[c(items_found), which(colnames(df_names) == "brand_found")] <- i
  }
}

#Renaming items to new itemnames --> aggregate itemLevels
df_test <- df_raw
for (k in c(1:125)) {
  on <- as.character(df_names[k, which(colnames(df_names) == "il_raw")])
  nn <- as.character(df_names[k, which(colnames(df_names) == "il_new")])
  for (i in c(1:32)){
    for (j in c(1:9835))
         df_test[j, i] <- replace(df_test[j, i], df_test[j, i] == on, nn)
  }
}
```

```{r Adding itemLevels}
# labels of itemLevels needs to be in lexicographical order for apriori as it picks by lexicographical order
## brand
df_brand_ordered <- df_names[c(order(df_names$brand)), ] 
transactions_raw@itemInfo$brand <- df_brand_ordered$brand
trans_brand <- arules::aggregate(transactions_raw, by = "brand")
df_trans_brand <- data.frame(as(trans_brand, "matrix"))

## category
df_cat_ordered <- df_names[c(order(df_names$category)), ]
transactions_raw@itemInfo$category <- df_cat_ordered$category
trans_category <- arules::aggregate(transactions_raw, by = "category")
df_trans_category <- data.frame(as(trans_category, "matrix"))

```
  
<a name="Comparison"></a>  
  
  
## 2. Comparison of product portfolio  
  
```{r Portfolio comparison, echo = FALSE, message = FALSE, warning = FALSE}
#### Compare Blackwell Electronix and Electronidex ####
## Prepare portfolio of Blackwell Electronix ##
#be_portfolio <- rbind(be_ex[, c(1:3, 17:18)],be_new[c(1:4, 7), c(1:3, 17:18)]) #w/ price, margin, and volume
be_products <- rbind(be_ex[-c(35:41), c(1:2,18)],be_new[c(1:4, 7), c(1:2,18)])
pred_vol_new <- c(152, 267, 225, 77, 734)
be_products[c(74:78), 3] <- pred_vol_new
names(be_products) <- c("category", "ProductNum", "volume")
be_categories <- as.character(unique(be_products$category))   #not required
be_portfolio <- setNames(data.frame(matrix(ncol = length(be_categories), nrow = 0)), c(be_categories))
vol_agg <- data.frame(aggregate(be_products$volume, by = list(be_products$category), FUN = sum))
              
for (i in be_categories) {
  be_portfolio[1, which(colnames(be_portfolio) == i)] <- vol_agg[which(vol_agg$Group.1 == i), 2]
}

## Prepare portfolio of Electronidex ##
ei_portfolio <- setNames(data.frame(matrix(ncol = ncol(df_trans_category), nrow = 0)), c(colnames(df_trans_category)))
for (i in c(1:ncol(df_trans_category))){
  ei_portfolio[1,i] <- length(which(df_trans_category[,i] == TRUE))
}

## Merge visualize portfolios from Blackwell and Electronix
#Merged via excel using be_portoflio and ei_portfolio
merged_portfolios <- read.csv(file = here("Data", "portfolio_comparison.csv"), header = TRUE)

ggplot(merged_portfolios, aes(x = category, y = volume)) + 
          facet_grid(company ~.) + 
          geom_col(aes(fill = category)) + 
          scale_color_brewer(palette = "Dark2") +
          ylim(0, 26000) + 
          theme(strip.text = element_text(face="bold", size = 12), 
                strip.background = element_rect(fill = "lightblue", colour = "black", size = 0.8)) + 
          theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) + 
          theme(axis.text = element_text(size = 12)) + 
          theme(axis.title = element_text(size = 15)) +
          xlab("Product Category") + ylab("Volume(Sum)") + 
          ggtitle("Product portfolio of Blackwell and Electronix") + 
          theme(title = element_text(size = 15)) + 
          theme(legend.position = "none")
```
'*'Accessories contain 'Computer Cords', 'Computer Stands', 'External Hardrives', 'Keyboard', 'Mouse', 'Mouse and Keyboard'
'*'Speakers contain 'Computer Headphones', 'Active Headphones'


  
<a name="Customer segments"></a>  
  
  
## 3. Analysis on customer segments (B2C, B2B)  
  
```{r Finding cutting values}
# Extract 'big products' (PC and Laptop)
bigprod <- c("Acer Aspire", "Alienware Laptop", "Apple MacBook Air",
             "Apple MacBook Pro", "ASUS Chromebook", "Dell Laptop",
             "Eluktronics Pro Gaming Laptop", "HP Laptop", "HP Notebook Touchscreen Laptop",
             "LG Touchscreen Laptop", "Acer Desktop", "ASUS Desktop", "CYBERPOWER Gamer Desktop",
             "Dell 2 Desktop", "Dell Desktop", "HP Desktop", "iMac",
             "Intel Desktop", "Lenovo Desktop Computer")
colnos_big <- c()
# Finding transactions for PC and/or laptop
for (i in bigprod) {
  colnos_big <- c(colnos_big, which(colnames(df_trans_bin) == i))
}

colnos_big
valueprod <- rowSums(df_trans_bin[, c(colnos_big)])
df_comparison <- df_trans_bin
df_comparison$valueprods <- valueprod

others <- rowSums(df_trans_bin[, -c(colnos_big)])
df_comparison$others <- others



# Extract 'printers'
printers <- c("Brother Printer", "Canon Office Printer", "DYMO Label Manker",
              "Epson Printer", "HP Wireless Printer")

colnos_print <- c()

for (i in printers) {
  colnos_print <- c(colnos_print, which(colnames(df_trans_bin) == i))
}

colnos_print
Printers <- rowSums(df_trans_bin[, c(colnos_print)])
df_comparison$Printers <- Printers

# Extract 'Monitors'
monitors <- c("Acer Monitor", "AOC Monitor", "ASUS 2 Monitor",
              "ASUS Monitor", "Dell Monitor", "HP Monitor",
              "LG Monitor", "Samsung Monitor", "Sceptre Monitor",
              "ViewSonic Monitor"
              )

colnons_monit <- c()

for (i in monitors) {
 colnons_monit <- c(colnons_monit, which(colnames(df_trans_bin) == i))
}

colnons_monit
monitors <- rowSums(df_trans_bin[, c(colnons_monit)])
df_comparison$monitors <- monitors


Trsize <- c()

for (i in 1:nrow(df_trans_bin)) {
 Trsize <- c(Trsize, sum(df_comparison[i,-c(126:128)]))
}

df_comparison$tsize <- Trsize

# found zero rows, zero items bought is not really a transaction

df_comparison <- df_comparison[-c(which(df_comparison$tsize == 0)),]

# Creaing df for cluster analysis
clusterdata_big <- c(df_comparison$valueprods, df_comparison$tsize)
clusterdata_others <- c(df_comparison$others, df_comparison$tsize)
clusterdata_bigothers <- c(df_comparison$valueprods, df_comparison$others)
clusterdata_print <- c(df_comparison$Printers, df_comparison$tsize)
clusterdata_monit <- c(df_comparison$monitors, df_comparison$tsize)

# Clustering analysis
trans_kmeans_big <- kmeans(clusterdata_big, 3)
trans_kmeans_others <- kmeans(clusterdata_others, 3)
trans_kmeans_bigothers <- kmeans(clusterdata_bigothers, 3)
trans_kmeans_print <- kmeans(clusterdata_print, 2)
trans_kmeans_monit <- kmeans(clusterdata_monit, 2)

# Visualization 
plot(df_comparison$Printers)
plot(df_comparison$monitors)

plot(x = df_comparison$valueprods, y = df_comparison$tsize, pch = trans_kmeans_big$cluster) +
points(trans_kmeans_big$centers, pch = 8, cex =3)

plot(x = df_comparison$others, y = df_comparison$tsize, pch = trans_kmeans_others$cluster) + points(trans_kmeans_others$centers, pch = 8, cex =3)

plot(x = df_comparison$valueprods, y = df_comparison$others, pch = trans_kmeans_bigothers$cluster) + points(trans_kmeans_bigothers$centers, pch = 8, cex =3)

plot(x = df_comparison$Printers, y = df_comparison$tsize, pch = trans_kmeans_print$cluster) + points(trans_kmeans_bigothers$centers, pch = 8, cex =3)

plot(x = df_comparison$monitors, y = df_comparison$tsize, pch = trans_kmeans_monit$cluster) + points(trans_kmeans_monit$centers, pch = 8, cex =3)


bigdeals <- which(df_comparison$tsize >= 10)

Bigdeals.df <- df_comparison[c(bigdeals),]

ggplot(data = Bigdeals.df, aes(x = Printers, y= tsize)) + geom_point()
ggplot(data = Bigdeals.df, aes(x = monitors, y= tsize)) + geom_point()

```

```{r Data split in B2C and B2B}
# Split total transactions into b2c and b2b by cutting values defined during cluster analysis
twocpus <- which(df_comparison$valueprods >= 2)
twoprints <- which(df_comparison$Printers >= 2)
twomons <- which(df_comparison$monitors >= 2)
tensize <- which(df_comparison$tsize >= 10)

rows_b2b_trans <- unique(c(twocpus, twoprints, twomons, tensize))

head(df_comparison[-c(rows_b2b_trans),])

# Create seperate S4 for b2c and b2b
trans_b2c <- as(df_comparison[-c(rows_b2b_trans), -c(126:130)] == 1, "transactions")
trans_b2b <- as(df_comparison[c(rows_b2b_trans), -c(126:130)] == 1, "transactions")
```

```{r }

```

    
<a name="Association rules"></a>  
  
  
## 4. Association rules mining 
  
```{r Looking for rules}
##Out of the box
#Define functions to create rules with apriori, remove redundant rules, sort rules and store rules in df
df_rules_func_on <- function(trans_data, rules_sorted_x, df_rules_x, support, confidence, min) {
rules_x <- apriori(trans_data, parameter = list(supp = support, conf = confidence, minlen = min, maxlen = 10)) 

rules_sorted_var <- sort(rules_x[!is.redundant(rules_x)], by = "lift", decreasing = TRUE)

df_rules_x <- data.frame(lhs = labels(lhs(rules_sorted_var)), 
                         rhs = labels(rhs(rules_sorted_var)), 
                         rules_sorted_var@quality)

df_rules_x$rhs_cat <- NA
df_rules_x$rhs_brand <- NA

for (i in c(1:nrow(df_rules_x))) {
    a <- gsub("{", "", df_rules_x[i, which(colnames(df_rules_x) == "rhs")], fixed = T)
    a2<- gsub("}", "", a, fixed = T)
    b <- df_names[which(df_names$il_raw == a2) ,which(colnames(df_names) == "category")]
    c <- df_names[which(df_names$il_raw == a2) ,which(colnames(df_names) == "brand")]
    df_rules_x[i, which(colnames(df_rules_x) == "rhs_cat")] <- b
    df_rules_x[i, which(colnames(df_rules_x) == "rhs_brand")] <- c
    i <- i + 1
  } 
  #df_rules_x <- df_rules_x
  rules_sorted_x <- rules_sorted_var
}

df_rules_func_off <- function(trans_data, df_rules_x, support, confidence, min) {
rules_x <- apriori(trans_data, parameter = list(supp = support , conf = confidence, minlen = min, maxlen = 10))
rules_sorted_variable <- sort(rules_x[!is.redundant(rules_x)], by = "lift", decreasing = TRUE)
df_rules_x <- data.frame(lhs = labels(lhs(rules_x)), rhs = labels(rhs(rules_x)), rules_x@quality)
}

#Create dfs for all 5 transaction datasets to get 5 df of rules
df_rules_product <- df_rules_func_on(trans_data = transactions_raw, 
                                     rules_sorted_x = rules_sorted_product, 
                                     df_rules_x = df_rules_product, 
                                     supp = 0.005, conf = 0.4, min = 2)

df_rules_category <- df_rules_func_off(trans_data = trans_category, df_rules_x = df_rules_category, 
                                     support = 0.015, confidence = 0.75, min = 2 )
df_rules_brand <- df_rules_func_off(trans_data = trans_brand, df_rules_x = df_rules_category, 
                                     support = 0.015, confidence = 0.70, min = 2 )
df_rules_b2c <- df_rules_func_on(trans_data = trans_b2c, df_rules_x = df_rules_b2c,
                                 support = 0.0003, confidence = 0.40, min = 2 )
df_rules_b2b <- df_rules_func_on(trans_data = trans_b2b, df_rules_x = df_rules_b2c,
                                 support = 0.003, confidence = 0.70, min = 2 )

arulesViz::ruleExplorer(rules_sorted)

## Select specific rules per item
ItemRules <- subset(rules_unique, items %in% "iMac")
inspect(ItemRules)
```

```{r Visualization}
plot(rules_sorted)
inspectDT(rules_sorted)                #interactive inspect
plotly_arules(rules_sorted[1:5],       #for interactive plots
              engine = "htmlwidget")   #interactive plot 
plot(rules_sorted[1:5], method = "two-key plot", control = list(type = "items", reorder = TRUE))
plot(rules_sorted[1:10], method = "paracoord", control = list(type = "items", reorder = TRUE))
plot(rules_sorted[1:5], method = "graph", control = list(type = "items", reorder = TRUE))
```

```{r}
rules <- apriori(trans_category, parameter = list(supp = 0.0015, conf = 0.75, minlen = 1, maxlen = 10))
func_redundant(rules)
func_sort(rules, "lift")
inspect(head(rules_sorted, 10))
summary(rules_sorted)

plot(rules_sorted)
inspectDT(rules_sorted)                #interactive inspect
plotly_arules(rules_sorted[1:5],       #for interactive plots
              engine = "htmlwidget")   #interactive plot


plot(rules_sorted[1:5], method = "two-key plot", control = list(type = "items", reorder = TRUE))
plot(rules_sorted[1:10], method = "paracoord", control = list(type = "items", reorder = TRUE))
plot(rules_sorted[1:5], method = "graph", control = list(type = "items", reorder = TRUE))
```


```{r}
rules <- apriori(trans_brand, parameter = list(supp = 0.015, conf = 0.75, minlen = 2, maxlen = 10))
func_redundant(rules)
func_sort(rules, "lift")
inspect(head(rules_sorted, 10))
summary(rules_sorted)

plot(rules_sorted)
inspectDT(rules_sorted)                #interactive inspect
plotly_arules(rules_sorted[1:5],       #for interactive plots
              engine = "htmlwidget")   #interactive plot 
plot(rules_sorted[1:5], method = "two-key plot", control = list(type = "items", reorder = TRUE))
plot(rules_sorted[1:10], method = "paracoord", control = list(type = "items", reorder = TRUE))
plot(rules_sorted[1:5], method = "graph", control = list(type = "items", reorder = TRUE))
```

<a name="Selection of rules"></a>  
  
  
## 5. Selection of rules
  
```{r}

```

